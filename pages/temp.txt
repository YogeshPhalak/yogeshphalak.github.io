// import React, { useEffect, useRef } from 'react';
// import { motion } from 'framer-motion';
// import { Github, Linkedin, Mail, Brain, ChevronDown, GraduationCap } from 'lucide-react';
//
// const BurningShipCanvas = () => {
//     const canvasRef = useRef(null);
//     const animationRef = useRef(null);
//     const imageDataRef = useRef(null);
//
//     useEffect(() => {
//         const canvas = canvasRef.current;
//         if (!canvas) return;
//
//         const ctx = canvas.getContext('2d', { alpha: false });
//         let time = 0;
//         let frameCount = 0;
//
//         const resizeCanvas = () => {
//             // Use device pixel ratio for sharp rendering
//             const dpr = window.devicePixelRatio || 1;
//             const rect = canvas.getBoundingClientRect();
//
//             canvas.width = rect.width * dpr;
//             canvas.height = rect.height * dpr;
//
//             ctx.scale(dpr, dpr);
//             canvas.style.width = rect.width + 'px';
//             canvas.style.height = rect.height + 'px';
//
//             // Pre-allocate ImageData buffer
//             imageDataRef.current = ctx.createImageData(canvas.width, canvas.height);
//         };
//
//         resizeCanvas();
//         window.addEventListener('resize', resizeCanvas);
//
//         const burningShip = (cx, cy, maxIter) => {
//             let x = 0, y = 0;
//             let iteration = 0;
//             let xx = 0, yy = 0;
//
//             while (xx + yy <= 4 && iteration < maxIter) {
//                 // Optimized: cache x*x and y*y
//                 const xtemp = xx - yy + cx;
//                 y = 2 * Math.abs(x * y) + cy;
//                 x = Math.abs(xtemp);
//                 xx = x * x;
//                 yy = y * y;
//                 iteration++;
//             }
//
//             return iteration;
//         };
//
//         const animate = () => {
//             const dpr = window.devicePixelRatio || 1;
//             const width = canvas.width;
//             const height = canvas.height;
//             const displayWidth = width / dpr;
//             const displayHeight = height / dpr;
//
//             // Only redraw every 2 frames for better performance
//             frameCount++;
//             if (frameCount % 2 !== 0) {
//                 time++;
//                 animationRef.current = requestAnimationFrame(animate);
//                 return;
//             }
//
//             // Clear canvas
//             ctx.fillStyle = 'rgb(15, 23, 42)';
//             ctx.fillRect(0, 0, displayWidth, displayHeight);
//
//             // Animated zoom and pan - optimized for Burning Ship's interesting regions
//             const zoom = 0.004 + Math.sin(time * 0.0003) * 0.0015;
//             const offsetX = -0.4 + Math.sin(time * 0.0002) * 0.2;
//             const offsetY = -0.6 + Math.cos(time * 0.00015) * 0.2;
//
//             const maxIter = 60;
//             const pixelSize = 2; // Render every 2nd pixel for performance
//
//             // Direct pixel manipulation for better performance
//             const imageData = imageDataRef.current;
//             const data = imageData.data;
//
//             for (let px = 0; px < width; px += pixelSize) {
//                 for (let py = 0; py < height; py += pixelSize) {
//                     const x0 = (px / dpr - displayWidth / 2) * zoom + offsetX;
//                     const y0 = (py / dpr - displayHeight / 2) * zoom + offsetY;
//
//                     const iter = burningShip(x0, y0, maxIter);
//
//                     if (iter < maxIter) {
//                         const ratio = iter / maxIter;
//                         const hue = (ratio * 360 + time * 0.05) % 360;
//
//                         // Convert HSL to RGB directly (faster than using CSS)
//                         const h = hue / 60;
//                         const s = 0.7;
//                         const l = 0.5 + ratio * 0.3;
//                         const c = (1 - Math.abs(2 * l - 1)) * s;
//                         const x = c * (1 - Math.abs((h % 2) - 1));
//                         const m = l - c / 2;
//
//                         let r, g, b;
//                         if (h < 1) { r = c; g = x; b = 0; }
//                         else if (h < 2) { r = x; g = c; b = 0; }
//                         else if (h < 3) { r = 0; g = c; b = x; }
//                         else if (h < 4) { r = 0; g = x; b = c; }
//                         else if (h < 5) { r = x; g = 0; b = c; }
//                         else { r = c; g = 0; b = x; }
//
//                         const red = Math.round((r + m) * 255);
//                         const green = Math.round((g + m) * 255);
//                         const blue = Math.round((b + m) * 255);
//                         const alpha = Math.round((0.3 + ratio * 0.4) * 255);
//
//                         // Fill pixel block for better performance
//                         for (let dx = 0; dx < pixelSize && px + dx < width; dx++) {
//                             for (let dy = 0; dy < pixelSize && py + dy < height; dy++) {
//                                 const index = ((py + dy) * width + (px + dx)) * 4;
//                                 data[index] = red;
//                                 data[index + 1] = green;
//                                 data[index + 2] = blue;
//                                 data[index + 3] = alpha;
//                             }
//                         }
//                     }
//                 }
//             }
//
//             // Put the image data on canvas
//             ctx.putImageData(imageData, 0, 0);
//
//             time++;
//             animationRef.current = requestAnimationFrame(animate);
//         };
//
//         animate();
//
//         return () => {
//             window.removeEventListener('resize', resizeCanvas);
//             if (animationRef.current) {
//                 cancelAnimationFrame(animationRef.current);
//             }
//         };
//     }, []);
//
//     return (
//         <canvas
//             ref={canvasRef}
//             className="absolute inset-0 w-full h-full"
//             style={{ opacity: 0.6 }}
//         />
//     );
// };
//
// const Hero = ({ scrollToSection }) => {
//     const handleScroll = (sectionId) => {
//         if (scrollToSection) {
//             scrollToSection(sectionId);
//         } else {
//             document.getElementById(sectionId)?.scrollIntoView({ behavior: 'smooth' });
//         }
//     };
//
//     return (
//         <section
//             id="hero"
//             className="relative min-h-screen flex items-center justify-center px-6 pt-20 overflow-hidden bg-slate-900"
//         >
//             {/* Burning Ship Animation Background */}
//             <BurningShipCanvas />
//
//             {/* Gradient Overlay for better text readability */}
//             <div className="absolute inset-0 bg-gradient-to-b from-slate-900/50 via-transparent to-slate-900/80 pointer-events-none" />
//
//             <div className="max-w-5xl text-center z-10 relative">
//                 <motion.div
//                     initial={{ scale: 0.5, opacity: 0 }}
//                     animate={{ scale: 1, opacity: 1 }}
//                     transition={{ duration: 0.8, ease: 'easeOut' }}
//                     className="mb-8 inline-block"
//                 >
//                     <div className="w-32 h-32 rounded-full bg-gradient-to-br from-purple-500 via-pink-500 to-cyan-500 p-1 animate-pulse">
//                         <div className="w-full h-full rounded-full bg-slate-900 flex items-center justify-center backdrop-blur-sm">
//                             <Brain size={48} className="text-cyan-400" />
//                         </div>
//                     </div>
//                 </motion.div>
//
//                 <motion.h1
//                     initial={{ opacity: 0, y: 20 }}
//                     animate={{ opacity: 1, y: 0 }}
//                     transition={{ duration: 0.6, delay: 0.2 }}
//                     className="text-6xl md:text-8xl font-bold mb-6 tracking-tight bg-gradient-to-r from-purple-400 via-pink-400 to-cyan-400 bg-clip-text text-transparent drop-shadow-lg"
//                 >
//                     Yogesh Phalak
//                 </motion.h1>
//
//                 <motion.p
//                     initial={{ opacity: 0, y: 20 }}
//                     animate={{ opacity: 1, y: 0 }}
//                     transition={{ duration: 0.6, delay: 0.4 }}
//                     className="text-2xl md:text-3xl text-white mb-8 font-light drop-shadow-md"
//                 >
//                     Exploring{' '}
//                     <span className="text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-400 font-medium">
//             Mechano-Intelligence
//           </span>
//                 </motion.p>
//
//                 <motion.p
//                     initial={{ opacity: 0, y: 20 }}
//                     animate={{ opacity: 1, y: 0 }}
//                     transition={{ duration: 0.6, delay: 0.6 }}
//                     className="text-lg text-gray-300 mb-12 max-w-2xl mx-auto drop-shadow-md"
//                 >
//                     PhD Candidate • Physical Reservoir Computing • Nonlinear Dynamics • Soft Robotics
//                 </motion.p>
//
//                 <motion.button
//                     initial={{ opacity: 0, y: 20 }}
//                     animate={{ opacity: 1, y: 0 }}
//                     transition={{ duration: 0.6, delay: 0.8 }}
//                     onClick={() => handleScroll('summary')}
//                     className="group px-8 py-4 bg-gradient-to-r from-purple-500 to-pink-500 rounded-full hover:scale-105 transition-all duration-300 flex items-center space-x-2 mx-auto shadow-lg shadow-purple-500/50"
//                 >
//                     <span className="font-semibold text-white">Know me in 2 minutes</span>
//                     <ChevronDown
//                         className="group-hover:translate-y-1 transition-transform text-white"
//                         size={20}
//                     />
//                 </motion.button>
//
//                 <motion.div
//                     initial={{ opacity: 0, y: 20 }}
//                     animate={{ opacity: 1, y: 0 }}
//                     transition={{ duration: 0.6, delay: 1 }}
//                     className="flex justify-center space-x-6 mt-12"
//                 >
//                     <a
//                         href="#"
//                         className="p-3 bg-slate-800/80 backdrop-blur-sm shadow-lg rounded-full hover:bg-gradient-to-r hover:from-purple-500 hover:to-pink-500 transition-all hover:scale-110"
//                     >
//                         <Github size={24} className="text-white" />
//                     </a>
//                     <a
//                         href="#"
//                         className="p-3 bg-slate-800/80 backdrop-blur-sm shadow-lg rounded-full hover:bg-gradient-to-r hover:from-purple-500 hover:to-pink-500 transition-all hover:scale-110"
//                     >
//                         <Linkedin size={24} className="text-white" />
//                     </a>
//                     <a
//                         href="#"
//                         className="p-3 bg-slate-800/80 backdrop-blur-sm shadow-lg rounded-full hover:bg-gradient-to-r hover:from-purple-500 hover:to-pink-500 transition-all hover:scale-110"
//                     >
//                         <Mail size={24} className="text-white" />
//                     </a>
//                 </motion.div>
//             </div>
//
//             <div className="absolute bottom-8 left-1/2 transform -translate-x-1/2 animate-bounce z-10">
//                 <ChevronDown className="text-gray-400" size={32} />
//             </div>
//         </section>
//     );
// };
//
// export default Hero;



import React, { useEffect, useRef, useCallback } from 'react';

/**
 * Renders an evolving, animated Burning Ship fractal.
 * This component is self-contained and manages its own animation loop.
 * It accepts an `isDarkMode` prop to change its color palette.
 */
const BurningShipCanvas = ({ isDarkMode }) => {
    const canvasRef = useRef(null);
    const animationRef = useRef(null); // To store the requestAnimationFrame ID
    const imageDataRef = useRef(null); // To store the pixel data buffer
    const timeRef = useRef(0); // Use ref for time to avoid re-renders

    // This is the fractal calculation logic.
    // It produces a beautiful, symmetrical variant.
    const burningShip = (cx, cy, maxIter) => {
        let x = 0, y = 0;
        let iteration = 0;
        let xx = 0, yy = 0;

        while (xx + yy <= 4 && iteration < maxIter) {
            // This logic creates a symmetrical, cross-like fractal.
            const xtemp = xx - yy + cx;
            y = 2 * Math.abs(x * y) + cy;
            x = Math.abs(xtemp); // The Math.abs() here is key to the shape
            xx = x * x;
            yy = y * y;
            iteration++;
        }

        return iteration;
    };

    // This is the core animation loop
    const animate = useCallback((isDark) => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const ctx = canvas.getContext('2d', { alpha: false });
        const dpr = window.devicePixelRatio || 1;
        const width = canvas.width;
        const height = canvas.height;
        const displayWidth = width / dpr;
        const displayHeight = height / dpr;

        const time = timeRef.current;

        // Set background color based on theme
        // Using a deep blue for dark mode and a very light gray for light mode
        ctx.fillStyle = isDark ? 'rgb(10, 10, 25)' : 'rgb(245, 245, 250)';
        ctx.fillRect(0, 0, displayWidth, displayHeight);

        // Animated zoom and pan parameters
        const zoom = 0.004 + Math.sin(time * 0.0003) * 0.0015;
        const offsetX = -0.4 + Math.sin(time * 0.0002) * 0.2;
        const offsetY = -0.6 + Math.cos(time * 0.00015) * 0.2;

        const maxIter = 60; // Max iterations. Lower = faster, less detail.

        // Get the pixel buffer
        const imageData = imageDataRef.current;
        if (!imageData || imageData.width !== width || imageData.height !== height) return;
        const data = imageData.data;

        const pixelSize = 1; // 1x1 for crisp rendering

        // Loop over each pixel
        for (let px = 0; px < width; px += pixelSize) {
            for (let py = 0; py < height; py += pixelSize) {
                // Map pixel to fractal coordinates
                const x0 = (px / dpr - displayWidth / 2) * zoom + offsetX;
                const y0 = (py / dpr - displayHeight / 2) * zoom + offsetY;

                const iter = burningShip(x0, y0, maxIter);

                let red = 0, green = 0, blue = 0, alpha = 0;

                if (iter < maxIter) {
                    const ratio = iter / maxIter;

                    // --- Theme-Aware Color Logic ---
                    if (isDark) {
                        // Dark Mode: "Nebula" palette - deep blues, purples, and fiery highlights
                        const hue = (240 + ratio * 120 + time * 0.05) % 360; // Blues, Purples, Pinks
                        const s = 1.0;
                        const l = 0.3 + ratio * 0.6; // Brighter points
                        const a = 0.2 + ratio * 0.8;

                        // Fast HSL-to-RGB
                        const h = hue / 60;
                        const c = (1 - Math.abs(2 * l - 1)) * s;
                        const x = c * (1 - Math.abs((h % 2) - 1));
                        const m = l - c / 2;
                        let r, g, b;
                        if (h < 1) { r = c; g = x; b = 0; }
                        else if (h < 2) { r = x; g = c; b = 0; }
                        else if (h < 3) { r = 0; g = c; b = x; }
                        else if (h < 4) { r = 0; g = x; b = c; }
                        else if (h < 5) { r = x; g = 0; b = c; }
                        else { r = c; g = 0; b = x; }

                        red = Math.round((r + m) * 255);
                        green = Math.round((g + m) * 255);
                        blue = Math.round((b + m) * 255);
                        alpha = Math.round(a * 255);

                    } else {
                        // Light Mode: "Watercolor" palette - soft blues, teals, and grays
                        const hue = (180 + ratio * 60 + time * 0.03) % 360; // Blues and Teals
                        const s = 0.6;
                        const l = 0.5 + ratio * 0.3; // More subtle range
                        const a = 0.3 + ratio * 0.6;

                        const h = hue / 60;
                        const c = (1 - Math.abs(2 * l - 1)) * s;
                        const x = c * (1 - Math.abs((h % 2) - 1));
                        const m = l - c / 2;
                        let r, g, b;
                        if (h < 1) { r = c; g = x; b = 0; }
                        else if (h < 2) { r = x; g = c; b = 0; }
                        else if (h < 3) { r = 0; g = c; b = x; }
                        else if (h < 4) { r = 0; g = x; b = c; }
                        else if (h < 5) { r = x; g = 0; b = c; }
                        else { r = c; g = 0; b = x; }

                        red = Math.round((r + m) * 255);
                        green = Math.round((g + m) * 255);
                        blue = Math.round((b + m) * 255);
                        alpha = Math.round(a * 255);
                    }
                }

                // Fill pixel block (handles pixelSize = 1)
                const index = (py * width + px) * 4;
                data[index] = red;
                data[index + 1] = green;
                data[index + 2] = blue;
                data[index + 3] = alpha;
            }
        }

        // Put the generated image data onto the canvas
        ctx.putImageData(imageData, 0, 0);

        // Increment time and request next frame
        timeRef.current++;
        animationRef.current = requestAnimationFrame(() => animate(isDark));

    }, []); // `animate` is stable, but we pass `isDark` manually

    // Setup effect
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');

        // Resize handler
        const resizeCanvas = () => {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();

            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;

            ctx.scale(dpr, dpr);

            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';

            // Re-create image data buffer for the new size
            imageDataRef.current = ctx.createImageData(canvas.width, canvas.height);
        };

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Start animation loop, passing the initial isDarkMode value
        animationRef.current = requestAnimationFrame(() => animate(isDarkMode));

        // Cleanup function
        return () => {
            window.removeEventListener('resize', resizeCanvas);
            if (animationRef.current) {
                cancelAnimationFrame(animationRef.current);
            }
        };
    }, [isDarkMode, animate]); // Reruns if isDarkMode changes to restart loop with new color logic

    return (
        <canvas
            ref={canvasRef}
            className="absolute inset-0 z-0 w-full h-full"
            style={{
                // Using blend mode for light mode can be very stylish
                mixBlendMode: isDarkMode ? 'normal' : 'difference',
                // Adjust opacity to your liking
                opacity: isDarkMode ? 0.7 : 1.0
            }}
        />
    );
};

export default BurningShipCanvas;




import React, {useEffect, useRef, useCallback, useState} from 'react';

/**
 * Renders an evolving, animated Burning Ship fractal.
 * - Detects mobile devices to render a single, static, optimized frame.
 * - Renders a full, continuous animation on desktop devices.
 * - Accepts an `isDarkMode` prop to change its color palette.
 */
const BurningShipCanvas = ({isDarkMode}) => {
    const canvasRef = useRef(null);
    const animationRef = useRef(null); // To store the requestAnimationFrame ID
    const imageDataRef = useRef(null); // To store the pixel data buffer
    const timeRef = useRef(0); // Use ref for time to avoid re-renders

    // State to track device type. Defaults to false (desktop).
    const [isMobile, setIsMobile] = useState(false);

    // --- Device Detection ---
    // Runs once on mount to check if it's a mobile device.
    useEffect(() => {
        const checkIsMobile = () => {
            return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        };
        setIsMobile(checkIsMobile());
    }, []); // Empty dependency array ensures this runs only once.

    // This is the fractal calculation logic.
    const burningShip = (cx, cy, maxIter) => {
        let x = 0, y = 0;
        let iteration = 0;
        let xx = 0, yy = 0;

        while (xx + yy <= 4 && iteration < maxIter) {
            const xtemp = xx - yy + cx;
            y = 2 * Math.abs(x * y) + cy;
            x = Math.abs(xtemp);
            xx = x * x;
            yy = y * y;
            iteration++;
        }
        return iteration;
    };

    // This is the core animation loop, now accepts `mobileCheck`
    const animate = useCallback((isDark, mobileCheck) => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const ctx = canvas.getContext('2d', {alpha: false});
        const dpr = window.devicePixelRatio || 1;
        const width = canvas.width;
        const height = canvas.height;
        const displayWidth = width / dpr;
        const displayHeight = height / dpr;

        const time = timeRef.current;

        ctx.fillStyle = isDark ? 'rgb(10, 10, 25)' : 'rgb(245, 245, 250)';
        ctx.fillRect(0, 0, displayWidth, displayHeight);

        const zoom = 0.004 + Math.sin(time * 0.0003) * 0.0015;
        const offsetX = -0.4 + Math.sin(time * 0.0002) * 0.2;
        const offsetY = -0.6 + Math.cos(time * 0.00015) * 0.2;

        const maxIter = 60;

        const imageData = imageDataRef.current;
        if (!imageData || imageData.width !== width || imageData.height !== height) return;
        const data = imageData.data;

        // --- PERFORMANCE OPTIMIZATION ---
        // On mobile, render 4x4 blocks. On desktop, render 1x1 (crisp).
        const pixelSize = mobileCheck ? 4 : 1;

        for (let px = 0; px < width; px += pixelSize) {
            for (let py = 0; py < height; py += pixelSize) {
                const x0 = (px / dpr - displayWidth / 2) * zoom + offsetX;
                const y0 = (py / dpr - displayHeight / 2) * zoom + offsetY;

                const iter = burningShip(x0, y0, maxIter);

                let red = 0, green = 0, blue = 0, alpha = 0;

                if (iter < maxIter) {
                    const ratio = iter / maxIter;
                    if (isDark) {
                        // Dark Mode: "Nebula"
                        const hue = (240 + ratio * 120 + time * 0.05) % 360;
                        const s = 1.0;
                        const l = 0.3 + ratio * 0.6;
                        const a = 0.2 + ratio * 0.8;

                        const h = hue / 60;
                        const c = (1 - Math.abs(2 * l - 1)) * s;
                        const x = c * (1 - Math.abs((h % 2) - 1));
                        const m = l - c / 2;
                        let r, g, b;
                        if (h < 1) {
                            r = c;
                            g = x;
                            b = 0;
                        } else if (h < 2) {
                            r = x;
                            g = c;
                            b = 0;
                        } else if (h < 3) {
                            r = 0;
                            g = c;
                            b = x;
                        } else if (h < 4) {
                            r = 0;
                            g = x;
                            b = c;
                        } else if (h < 5) {
                            r = x;
                            g = 0;
                            b = c;
                        } else {
                            r = c;
                            g = 0;
                            b = x;
                        }
                        red = Math.round((r + m) * 255);
                        green = Math.round((g + m) * 255);
                        blue = Math.round((b + m) * 255);
                        alpha = Math.round(a * 255);
                    } else {
                        // Light Mode: "Watercolor"
                        const hue = (180 + ratio * 60 + time * 0.03) % 360;
                        const s = 0.6;
                        const l = 0.5 + ratio * 0.3;
                        const a = 0.3 + ratio * 0.6;

                        const h = hue / 60;
                        const c = (1 - Math.abs(2 * l - 1)) * s;
                        const x = c * (1 - Math.abs((h % 2) - 1));
                        const m = l - c / 2;
                        let r, g, b;
                        if (h < 1) {
                            r = c;
                            g = x;
                            b = 0;
                        } else if (h < 2) {
                            r = x;
                            g = c;
                            b = 0;
                        } else if (h < 3) {
                            r = 0;
                            g = c;
                            b = x;
                        } else if (h < 4) {
                            r = 0;
                            g = x;
                            b = c;
                        } else if (h < 5) {
                            r = x;
                            g = 0;
                            b = c;
                        } else {
                            r = c;
                            g = 0;
                            b = x;
                        }
                        red = Math.round((r + m) * 255);
                        green = Math.round((g + m) * 255);
                        blue = Math.round((b + m) * 255);
                        alpha = Math.round(a * 255);
                    }
                }

                // Fill pixel block
                if (pixelSize === 1) {
                    const index = (py * width + px) * 4;
                    data[index] = red;
                    data[index + 1] = green;
                    data[index + 2] = blue;
                    data[index + 3] = alpha;
                } else {
                    // Optimized block fill for mobile's static render
                    for (let dx = 0; dx < pixelSize && px + dx < width; dx++) {
                        for (let dy = 0; dy < pixelSize && py + dy < height; dy++) {
                            const index = ((py + dy) * width + (px + dx)) * 4;
                            data[index] = red;
                            data[index + 1] = green;
                            data[index + 2] = blue;
                            data[index + 3] = alpha;
                        }
                    }
                }
            }
        }

        ctx.putImageData(imageData, 0, 0);

        // --- PERFORMANCE OPTIMIZATION ---
        // Only loop the animation if it's NOT a mobile device.
        if (!mobileCheck) {
            timeRef.current++;
            animationRef.current = requestAnimationFrame(() => animate(isDark, mobileCheck));
        }

    }, []); // `animate` is stable, gets state via arguments

    // Setup effect
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');

        const resizeCanvas = () => {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            imageDataRef.current = ctx.createImageData(canvas.width, canvas.height);

            // --- Re-render on resize ---
            // On mobile, we need to re-render the static frame.
            // On desktop, the animation loop will handle it.
            if (isMobile) {
                // Manually trigger a single render
                animate(isDarkMode, isMobile);
            }
        };

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Start animation loop, passing both theme and mobile state
        animationRef.current = requestAnimationFrame(() => animate(isDarkMode, isMobile));

        // Cleanup function
        return () => {
            window.removeEventListener('resize', resizeCanvas);
            if (animationRef.current) {
                cancelAnimationFrame(animationRef.current);
            }
        };
    }, [isDarkMode, isMobile, animate]); // Re-runs if theme or mobile state changes

    return (
        <canvas
            ref={canvasRef}
            className="absolute inset-0 z-0 w-full h-full"
            style={{
                mixBlendMode: isDarkMode ? 'normal' : 'difference',
                opacity: isDarkMode ? 0.7 : 1.0
            }}
        />
    );
};

export default BurningShipCanvas;

